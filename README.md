# Фінальний проєкт з курсу "Базові алгоритми та структури даних"

**Цей проєкт є набором з семи практичних завдань, що демонструють володіння основними алгоритмами та структурами даних.**

## Опис завдань

### Завдання 1: Робота з однозв'язним списком

**Мета:** Реалізувати основні операції над однозв'язним списком.

- **Структура:** Створено класи `Node` та `LinkedList`.
- **Реалізовано функції:**
  1.  `reverse()`: Реверсування списку шляхом зміни посилань між вузлами.
  2.  `sort()`: Сортування списку методом злиття (`Merge Sort`), який є ефективним для зв'язних списків.
  3.  `merge_two_sorted_lists()`: Об'єднання двох відсортованих списків в один новий відсортований список.

### Завдання 2: Візуалізація фрактала "дерево Піфагора"

**Мета:** Використати рекурсію для створення та візуалізації фрактала.

-1. **Функція `draw_tree`:**
- Приймає параметри: довжина гілки, об'єкт черепашки та рівень рекурсії.
- Якщо рівень рекурсії більше **0**, малює гілку, а потім рекурсивно викликає себе для малювання двох нових гілок з фіксованим кутом розгалуження та коефіцієнтом зменшення довжини гілки.

2. **Функція `main`:**
- Запитує у користувача рівень рекурсії.
- Налаштовує екран та об'єкт черепашки.
- Викликає функцію `draw_tree` для малювання дерева.
- Приховує черепашку та утримує вікно відкритим.

### Завдання 3: Алгоритм Дейкстри

**Мета:** Знайти найкоротші шляхи від однієї вершини до всіх інших у зваженому графі.

- **Структура:** Граф представлено у вигляді списків суміжності.
- **Оптимізація:** Для ефективного вибору вершини з найменшою поточною відстанню використано бінарну купу (піраміду) через модуль `heapq`. Це дозволяє досягти оптимальної часової складності алгоритму.

### Завдання 4: Візуалізація бінарної купи

**Мета:** Візуалізувати бінарну купу, представлену у вигляді масиву.

- **Технології:** Використано бібліотеки `networkx` та `matplotlib` для побудови та відображення графа.
- **Логіка:** Створено функцію `build_heap_tree`, яка рекурсивно перетворює масив (купу) на деревоподібну структуру об'єктів `Node`. Отримане дерево передається у готову функцію візуалізації.

### Завдання 5: Візуалізація обходу бінарного дерева

**Мета:** Продемонструвати обходи дерева в глибину **(DFS)** та в ширину **(BFS)** з візуальним супроводом.

- **Логіка:**
  - **DFS (Depth-First Search):** Реалізовано ітеративно з використанням стека.
  - **BFS (Breadth-First Search):** Реалізовано ітеративно з використанням черги (`collections.deque`).
- **Візуалізація:** Вузли дерева розфарбовуються в процесі обходу від темних до світлих відтінків, що наочно показує порядок відвідування вершин для кожного з алгоритмів.

### Завдання 6: Жадібні алгоритми та динамічне програмування

**Мета:** Розв'язати задачу про рюкзак (вибір їжі з максимальною калорійністю при обмеженому бюджеті) двома методами.

- **Жадібний алгоритм:** Сортує предмети за співвідношенням калорій до вартості та обирає найвигідніші. Це швидка евристика, що не завжди гарантує оптимальне рішення для задачі 0/1.
- **Динамічне програмування:** Будує DP-таблицю для знаходження гарантовано оптимального рішення. Цей метод є обчислювально складнішим, але забезпечує найкращий можливий результат.

### Завдання 7: Метод Монте-Карло

**Мета:** Використати метод Монте-Карло для симуляції кидання двох кубиків та аналізу ймовірностей.

- **Симуляція:** Проведено велику кількість (напр., 1,000,000) ітерацій кидання кубиків.
- **Аналіз:**
  1.  Підраховано частоту випадіння кожної можливої суми.
  2.  Обчислено ймовірності на основі симуляції.
  3.  Результати порівняно з точними аналітичними розрахунками.
- **Висновок:** Симуляція підтвердила теоретичні розрахунки, продемонструвавши дію закону великих чисел. Результати представлено у вигляді таблиці та графіка.
